<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ghost Detection</title>
<style>
  body { margin: 0; overflow: hidden; background: black; color: lime; font-family: monospace; }
  canvas { position: absolute; top: 0; left: 0; }
  #overlay { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(255,0,0,0.3); display:none; animation: blink 1s infinite; }
  @keyframes blink { 0%,50%,100%{opacity:0.3} 25%,75%{opacity:0.7} }
  #status { position:absolute; bottom:10px; left:10px; font-size:16px; color:lime; }
  #settings { position:absolute; top:10px; right:10px; color:lime; font-size:14px; background:#0008; padding:5px; border-radius:4px; }
  #settings label{ display:block; margin-bottom:2px; }
</style>
</head>
<body>
<div id="overlay"></div>
<div id="status">SYSTEM INITIALIZING...</div>
<div id="settings">
  <label><input type="checkbox" id="motionToggle" checked> Motion Detection</label>
  <label><input type="checkbox" id="audioToggle" checked> Audio Alert</label>
  <label><input type="checkbox" id="recordToggle"> Recording</label>
</div>
<canvas id="videoCanvas"></canvas>
<canvas id="audioCanvas" width="640" height="100"></canvas>

<!-- CDN読み込み -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

<script>
document.addEventListener('deviceready', init, false);

let video, videoCanvas, videoCtx;
let audioCtx, micStream, analyser, dataArray;
let model;
let prevFrames = [], ghostTrails = [];
const maxHistory = 5, maxTrails = 10;
let overlayEl, statusEl;
let motionEnabled = true, audioEnabled = true, recordingEnabled = false;
let audioThreshold = 200;
let mediaRecorder, recordedChunks = [];

// 設定トグル
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('motionToggle').addEventListener('change', e=>motionEnabled=e.target.checked);
  document.getElementById('audioToggle').addEventListener('change', e=>audioEnabled=e.target.checked);
  document.getElementById('recordToggle').addEventListener('change', e=>toggleRecording(e.target.checked));
});

async function init() {
  overlayEl = document.getElementById('overlay');
  statusEl = document.getElementById('status');
  await initMedia();
  await loadModel();
  initMotion();
  requestAnimationFrame(drawLoop);
}

async function initMedia() {
  try {
    video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;

    const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    video.srcObject = stream;

    videoCanvas = document.getElementById('videoCanvas');
    videoCtx = videoCanvas.getContext('2d');
    videoCanvas.width = 640;
    videoCanvas.height = 480;

    // 音声解析
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    micStream = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    micStream.connect(analyser);
    analyser.fftSize=256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    // 録画準備
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = saveRecording;

    updateStatus('AWAITING ANOMALY...');
  } catch(e) {
    console.error(e);
    updateStatus('ERROR: CAMERA/MIC ACCESS FAILED');
  }
}

async function loadModel() {
  updateStatus('LOADING MODEL...');
  model = await cocoSsd.load();
  updateStatus('MODEL LOADED');
}

function initMotion() {
  if(window.DeviceMotionEvent){
    window.addEventListener('devicemotion', e=>{
      if(motionEnabled){
        const total = Math.abs(e.acceleration.x)+Math.abs(e.acceleration.y)+Math.abs(e.acceleration.z);
        if(total>30) triggerUnknownAlert();
      }
    });
  }
}

async function drawLoop() {
  if(video.videoWidth && video.videoHeight){
    videoCanvas.width = video.videoWidth;
    videoCanvas.height = video.videoHeight;
    videoCtx.drawImage(video,0,0);

    let frame = videoCtx.getImageData(0,0,videoCanvas.width,videoCanvas.height);
    let data = frame.data;

    prevFrames.push(new Uint8ClampedArray(data));
    if(prevFrames.length>maxHistory) prevFrames.shift();

    let diffPositions=[];
    if(prevFrames.length>=2){
      const prev = prevFrames[prevFrames.length-2];
      for(let i=0;i<data.length;i+=4){
        const delta=Math.abs(data[i]-prev[i])+Math.abs(data[i+1]-prev[i+1])+Math.abs(data[i+2]-prev[i+2]);
        if(delta>50){
          const idx=i/4;
          const x=idx%videoCanvas.width;
          const y=Math.floor(idx/videoCanvas.width);
          diffPositions.push({x,y});
        }
      }
      if(diffPositions.length/(data.length/4)>0.02) triggerUnknownAlert();
      drawGhostTrails(diffPositions);
    }
    videoCtx.putImageData(frame,0,0);
  }

  drawAudio();
  await detectUnknownEntities();
  requestAnimationFrame(drawLoop);
}

function drawGhostTrails(diffPositions){
  if(diffPositions.length===0) return;
  ghostTrails.push(diffPositions);
  if(ghostTrails.length>maxTrails) ghostTrails.shift();
  videoCtx.strokeStyle='lime';
  videoCtx.lineWidth=2;
  ghostTrails.forEach(trail=>{
    videoCtx.beginPath();
    trail.forEach((p,i)=>i===0?videoCtx.moveTo(p.x,p.y):videoCtx.lineTo(p.x,p.y));
    videoCtx.stroke();
  });
}

function drawAudio(){
  analyser.getByteFrequencyData(dataArray);
  const audioCanvas=document.getElementById('audioCanvas');
  const ctx=audioCanvas.getContext('2d');
  ctx.clearRect(0,0,audioCanvas.width,audioCanvas.height);
  ctx.fillStyle='lime';
  const barWidth=audioCanvas.width/dataArray.length;
  for(let i=0;i<dataArray.length;i++){
    const barHeight=dataArray[i];
    ctx.fillRect(i*barWidth,audioCanvas.height-barHeight,barWidth,barHeight);
    if(audioEnabled && barHeight>audioThreshold) triggerAudioAlert();
  }
}

function triggerAudioAlert(){ showOverlay('AUDIO ANOMALY DETECTED'); }
function triggerUnknownAlert(){ showOverlay('UNKNOWN ENTITY DETECTED'); }

function showOverlay(msg){
  overlayEl.style.display='block';
  updateStatus(msg);
  setTimeout(()=>overlayEl.style.display='none',1000);
}

async function detectUnknownEntities(){
  if(!model || !video.videoWidth) return;
  const predictions = await model.detect(video);
  predictions.forEach(pred=>{
    if(!['person','chair','table'].includes(pred.class)) triggerUnknownAlert();
  });
}

function updateStatus(msg){ statusEl.textContent=msg; }

// 録画機能
function toggleRecording(enable){
  recordingEnabled=enable;
  if(enable){
    recordedChunks=[];
    mediaRecorder.start();
    updateStatus('RECORDING STARTED');
  } else {
    mediaRecorder.stop();
    updateStatus('RECORDING STOPPED');
  }
}
function saveRecording(){
  const blob=new Blob(recordedChunks,{type:'video/webm'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='ghost_recording.webm'; a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
